import cadquery as cq
import json


# TODO: generate_screen_hole
# TODO: add screen hole
# TODO: generate_settings buttons
# TODO: Add settings buttons


# Function that generates a USB-C receptacle port cutout using a height, width, corner radius, and wall thickness
def generate_usb_c(usb_c=None):
    if usb_c is None:
        usb_c = {"height": 4, "width": 11, "corner_radius": 1, "wall_thickness": 2}
    return (
        cq.Workplane()
        .rect(usb_c["width"], usb_c["height"])
        .extrude(usb_c["wall_thickness"])
        .edges("|Z")
        .fillet(usb_c["corner_radius"])
    )


# Function the cuts a USB-C receptacle port from a plane
def add_usb_c(
    plane=None,
    usb_c=None,
    x_offset=0,
    x_rotate=0,
    y_offset=0,
    y_rotate=0,
    z_offset=0,
    z_rotate=0,
):
    # If there is no plane, then none is returned
    if plane is not None:
        # If there is a plane, a port for the usb-c is cut out of it
        if usb_c is not None:
            # The usb-c is generated using generate_usb_c, then translated using the offsets and rotated as necessary
            plane = plane.cut(
                generate_usb_c(usb_c)
                .translate((x_offset, y_offset, z_offset))
                .rotate((0, 0, 0), (1, 0, 0), x_rotate)
                .rotate((0, 0, 0), (0, 1, 0), y_rotate)
                .rotate((0, 0, 0), (0, 0, 1), z_rotate)
            )
    return plane


# Function to generate text for button caps and key caps
def generate_text(text=None):
    # If no text has been passed, an empty Workplane is returned
    if text is None:
        return cq.Workplane()
    # If text is passed, it will generate text for the cap
    else:
        return cq.Workplane().text(
            text["content"],
            text["size"],
            distance=text["depth"],
            font=text["font"],
            halign="center",
            valign="center",
        )


# Function to add text to a plane, taking a plane, the text, and offsets
def add_text(plane=None, text=None, x_offset=0.0, y_offset=0.0, z_offset=0.0):
    # If a plane is not passed, None is returned
    if plane is not None:
        # If there is a plane, text is added to it
        if text is not None:
            # Text is generated using generate_text, then translated using the offsets accounting for depth
            text_workplane = generate_text(text).translate(
                (x_offset, y_offset, z_offset - text["depth"])
            )
            # If the text is more than 0 depth, it is cut out of the plane
            if text["depth"] > 0:
                plane = plane.cut(text_workplane)
            # If the text has a negative depth, it is added to the plane
            elif text["depth"] < 0:
                plane = plane.add(text_workplane)
            # A depth of 0 results in the text not being put on the plane
    return plane


# TODO: Implement
# TODO: Comment
def generate_curve():
    pass


# TODO: Implement
# TODO: Comment
def add_curve():
    pass


# Function used to generate the mounts for key caps and button caps
def generate_mount(mount_values=None):
    # If no mount values are passed, mount_values is instantiated to prevent errors
    if mount_values is None:
        mount_values = {"type": "", "diameter": 0}
    # Create the mount based on the mount type
    if mount_values["type"].upper() == "MX":
        # MX mounts generate the mount's X-Point using the width and length of the X_point
        # the current implementation assumes uniformity of the X_point's arms
        mount_x_point = (
            cq.Workplane()
            .rect(mount_values["X_point_width"], mount_values["X_point_length"])
            .rect(mount_values["X_point_length"], mount_values["X_point_width"])
            .extrude(mount_values["height"])
        )
        # The mount is generated by cutting the X_point out of the mount's radius (diameter/2)
        mount = (
            cq.Workplane()
            .circle(mount_values["diameter"] / 2)
            .extrude(mount_values["height"])
            .cut(mount_x_point)
        )
    elif mount_values["type"].upper() == "STEM":
        # Stem creates a solid mount for the key
        mount = (
            cq.Workplane()
            .circle(mount_values["diameter"] / 2)
            .extrude(mount_values["height"])
        )
    else:
        # raise ValueError("Mount most have a specified type")
        # If there is no mount, an empty workplane is returned
        mount = cq.Workplane()
    return mount


# TODO: Systematic fillet
def generate_key_cap(
    units=None, dimensions=None, bevel=False, mount_values=None, text=None
):
    # Parameters derived from the dictionaries values
    top_width = units["top"] * dimensions["width"]
    top_length = units["top"] * dimensions["length"]
    base_width = units["base"] * dimensions["width"]
    base_length = units["base"] * dimensions["length"]
    # Create the base profile and loft to the top profile
    keycap_body = (
        cq.Workplane("XY")
        .rect(base_width, base_length)
        .workplane(offset=dimensions["wall_height"] + dimensions["thickness"])
        .rect(top_width, top_length)
        .loft(combine=True)
    )
    # Create the inner hollow part
    inner_keycap = (
        cq.Workplane("XY")
        .rect(
            (units["base"] - (dimensions["thickness"] * 2)) * dimensions["width"],
            (units["base"] - (dimensions["thickness"] * 2)) * dimensions["length"],
        )
        .workplane(offset=dimensions["wall_height"])
        .rect(
            (top_width - (dimensions["thickness"] * 2)) * dimensions["width"],
            (top_length - (dimensions["thickness"] * 2)) * dimensions["length"],
        )
        .loft(combine=True)
    )
    # Cut out the inner keycap to create the hollow
    keycap = keycap_body.cut(inner_keycap)
    # Add rounded corners if requested
    if bevel:
        keycap = keycap.edges().fillet(0.4)
    # Add text to the keycap
    keycap = add_text(
        plane=keycap,
        text=text,
        x_offset=text.get("x", 0),
        y_offset=text.get("y", 0),
        z_offset=dimensions["thickness"] + dimensions["wall_height"],
    )
    # Generate the mount
    mount = generate_mount(mount_values)
    # Create the cap assembly
    cap = (
        cq.Assembly()
        .add(keycap)
        .add(
            mount,
            loc=cq.Location((0, 0, dimensions["wall_height"] - mount_values["height"])),
        )
    )
    # Return the cap
    return cap


# Function for adding a hole for a key to a plane, using offsets
def add_key_hole(
    plane=None,
    thickness=0,
    width=0,
    length=0,
    x_offset=0.0,
    y_offset=0.0,
    z_offset=0.0,
    rotation=0,
):
    # If a plane is not passed, None is returned
    if plane is not None:
        # If there is a plane, and a diameter is defined, the hole is cut using the parameters
        if width != 0 and length != 0:
            key_hole = (
                cq.Workplane()
                .rect(width, length)
                .extrude(thickness)
                .rotate((0, 0, 0), (0, 0, 1), rotation)
                .translate((x_offset, y_offset, z_offset))
            )
            plane = plane.cut(key_hole)
    return plane


# generate_button_cap is a function for generating button caps
# the function produces a default button cap if no values are passed to it
# the default button is 24mm in diameter and 2mm thick with no walls or  bevel
# the default mount is the Cherry MX clone found on Kailh Red switches
def generate_button_cap(
    diameter=24.0, thickness=2.0, bevel=False, wall=None, mount_values=None, text=None
):
    # Create the top of the button, using the diameter and thickness
    top = cq.Workplane().circle(diameter / 2).extrude(thickness)
    # Add bevel to the button, if it has been requested
    if bevel:
        top = top.faces(">Z").edges().fillet(1)
    # text is added to the top of the button, if text is none this will just return the top
    top = add_text(
        plane=top,
        text=text,
        x_offset=text.get("x", 0),
        y_offset=text.get("y", 0),
        z_offset=thickness,
    )
    # Convert the button cap into an assembly
    cap = cq.Assembly().add(top, loc=cq.Location((0, 0, wall["height"])))
    # If no wall is provided, an empty wall is created
    if wall is None:
        wall = {"thickness": 0.0, "height": 0.0}
    # If the walls have a thickness and height above 0, they are generated then added to the assembly
    # The walls add half the thickness, as the 'height' is the wall size after the button cap starts
    if wall["thickness"] > 0.0 and wall["height"] > 0.0:
        walls = (
            cq.Workplane()
            .circle(diameter / 2)
            .circle((diameter / 2) - wall["thickness"])
            .extrude(wall["height"] + (thickness / 2))
        )
        cap.add(walls)
    # Generate the mount for the button
    mount = generate_mount(mount_values)
    # Combine all parts of the button cap
    cap = cap.add(
        mount, loc=cq.Location((0, 0, wall["height"] - mount_values["height"]))
    )
    # Return the assembled button cap
    return cap


# Function for adding a hole for a button to a plane, using offsets
def add_button_hole(
    plane=None, diameter=0, thickness=0, x_offset=0.0, y_offset=0.0, z_offset=0.0
):
    # If a plane is not passed, None is returned
    if plane is not None:
        # If there is a plane, and a diameter is defined, the hole is cut using the parameters
        if diameter != 0:
            button_hole = (
                cq.Workplane()
                .circle(diameter / 2)
                .extrude(thickness)
                .translate((x_offset, y_offset, z_offset))
            )
            plane = plane.cut(button_hole)
    return plane


# TODO: Comment
# TODO: Add USB_C
# TODO: Add screen
def generate_simple_base(
    base=None,
    buttons=None,
    keys=None,
):
    # Set default base parameters
    if base is None:
        base = {
            "height": 50,
            "width": 200,
            "length": 100,
            "thickness": 5,
            "rounded_edges": False,
            "screw_diameter": 1,
            "text": None,
        }
    # Set corner positions in advance
    positions = [
        (
            -(base["width"] / 2 - base["thickness"]),
            -(base["length"] / 2 - base["thickness"]),
        ),
        (
            -(base["width"] / 2 - base["thickness"]),
            base["length"] / 2 - base["thickness"],
        ),
        (
            base["width"] / 2 - base["thickness"],
            -(base["length"] / 2 - base["thickness"]),
        ),
        (base["width"] / 2 - base["thickness"], base["length"] / 2 - base["thickness"]),
        (0, -(base["length"] / 2 - base["thickness"])),
        (0, base["length"] / 2 - base["thickness"]),
    ]
    # Create top base
    top_base = (
        cq.Workplane().rect(base["width"], base["length"]).extrude(base["thickness"])
    )
    # Generate bottom of base
    bottom_base = (
        cq.Workplane().rect(base["width"], base["length"]).extrude(base["height"])
    )
    inner_base = (
        cq.Workplane()
        .rect(
            base["width"] - (base["thickness"] * 2),
            base["length"] - (base["thickness"] * 2),
        )
        .extrude(base["height"] - base["thickness"])
    )
    bottom_base = bottom_base.cut(inner_base.translate((0, 0, base["thickness"])))
    # Add rounded edges
    if base["bevel"]:
        bottom_base = bottom_base.fillet((base["thickness"] / 2) - 0.01)
    # Cut the top from the bottom, to result in a flat plane
    bottom_base = bottom_base.cut(
        top_base.translate((0, 0, base["height"] - base["thickness"]))
    )
    # Add rounded edges
    if base["bevel"]:
        top_base = top_base.faces(">Z").edges().fillet(base["thickness"] / 2)
    # Add corners for screw/plugs
    corner_radius = base["thickness"]
    corner = (
        cq.Workplane()
        .circle(corner_radius)
        .extrude(base["height"] - (base["thickness"] * 2))
    )
    corners = cq.Workplane()
    for pos in positions:
        corners = corners.union(
            corner.translate(pos).translate((0, 0, base["thickness"]))
        )
    bottom_base = bottom_base.union(corners)
    # Add the screw holes or slots
    corner_holes = cq.Workplane()
    screw_holes = cq.Workplane()
    if (base["screw_diameter"] / 2) > 0.0:
        corner_hole = (
            cq.Workplane().circle(corner_radius / 2).extrude(base["thickness"] / 2)
        )
        screw_hole = (
            cq.Workplane().circle((base["screw_diameter"] / 2)).extrude(base["height"])
        )
    else:
        corner_hole = (
            cq.Workplane().circle(corner_radius / 2).extrude(base["thickness"])
        )
        screw_hole = cq.Workplane()
    for pos in positions:
        corner_holes = corner_holes.union(corner_hole.translate(pos))
        screw_holes = screw_holes.union(screw_hole.translate(pos))
    bottom_base = bottom_base.union(
        corner_holes.translate((0, 0, base["height"] - base["thickness"]))
    )
    if (base["screw_diameter"] / 2) > 0.0:
        bottom_base = bottom_base.cut(screw_holes.translate((0, 0, base["thickness"])))
    # Add the screw holes or slots
    top_base = top_base.cut(corner_holes)
    if (base["screw_diameter"] / 2) > 0.0:
        top_base = top_base.cut(screw_holes)
    # Translate top base to have bottom left in 0,0
    top_base = top_base.translate((base["width"] / 2, base["length"] / 2))
    # Add buttons if it is not none
    if buttons is not None:
        for button in buttons.values():
            top_base = add_button_hole(
                plane=top_base,
                diameter=(button["diameter"] + 2.0),
                thickness=base["thickness"],
                x_offset=button["x"],
                y_offset=button["y"],
            )
    # Add keys if it is not none
    if keys is not None:
        for key in keys.values():
            top_base = add_key_hole(
                plane=top_base,
                width=(key["units"]["base"] * key["dimensions"]["width"]) + 2,
                length=(key["units"]["base"] * key["dimensions"]["length"]) + 2,
                thickness=base["thickness"],
                x_offset=key["x"],
                y_offset=key["y"],
                rotation=key.get("rotation", 0),
            )
    # Check base is still a dict, and add text if it is not none.
    if isinstance(base, dict) and base.get("text") is not None:
        top_base = add_text(
            plane=top_base,
            text=base["text"],
            x_offset=base["text"].get("x", 0),
            y_offset=base["text"].get("y", 0),
            z_offset=base["thickness"],
        )
    return top_base, bottom_base


# TODO: Add 'modular' option to base
# TODO: Generate ModularBase ipynb
# TODO: Comment
# TODO: Implement
def generate_modular_base(base=None):
    pass


# TODO: Implement
# TODO: Comment
def calculate_base_from_parts(buttons=None, keys=None):
    return {}


# TODO: Comment
# TODO: Rework
def generate_controller(
    base=None,
    buttons=None,
    keys=None,
):
    if base.get("modular", False):
        pass
    key_steps = []
    base_top, base_bottom = generate_simple_base(base, buttons, keys)
    button_steps = []
    if buttons is not None:
        for button_name, button_values in buttons.items():
            button_steps.append(
                [
                    generate_button_cap(
                        diameter=button_values["diameter"],
                        thickness=button_values.get("thickness", 2.0),
                        bevel=button_values.get("bevel", False),
                        mount_values=button_values.get("mount", None),
                        wall=button_values.get("wall", None),
                        text=button_values.get("text", None),
                    ),
                    button_name,
                ]
            )
    if keys is not None:
        for key_name, key_values in keys.items():
            key_steps.append(
                [
                    generate_key_cap(
                        units=key_values.get("units", None),
                        dimensions=key_values.get("dimensions", None),
                        bevel=key_values.get("bevel", False),
                        mount_values=key_values.get("mount", None),
                        text=key_values.get("text", None),
                    ),
                    key_name,
                ]
            )
    return base_top, base_bottom, button_steps, key_steps


# TODO: Comment
def generate_controller_files(
    path="generated_files/", base=None, buttons=None, keys=None
):
    # Generate a base from the buttons and keys
    if base is None:
        base = calculate_base_from_parts(buttons=buttons, keys=keys)
    base_top, base_bottom, button_steps, key_steps = generate_controller(
        base=base, buttons=buttons, keys=keys
    )
    # Generate the steps for the top and bottom base
    cq.exporters.export(base_top, path + "base_top.step")
    cq.exporters.export(base_bottom, path + "base_bottom.step")
    # Generate the steps for the buttons
    for button in button_steps:
        button[0].save(path + button[1] + ".step")
    # Generate the steps for the keys
    for key in key_steps:
        key[0].save(path + key[1] + ".step")


# TODO: Comment
if __name__ == "__main__":
    with open("test_files/_test.json", encoding="utf-8") as test_file:
        test_dict = json.load(test_file)

    generate_controller_files(
        path="test_files/",
        base=test_dict["base"],
        buttons=test_dict["buttons"],
        keys=test_dict["keys"],
    )
